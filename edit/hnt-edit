#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
import tempfile
import io
from pathlib import Path

def run_command(cmd, stdin_content=None, capture_output=True, check=True, text=True):
    """Helper function to run a command."""
    try:
        process = subprocess.run(
            cmd,
            input=stdin_content,
            capture_output=capture_output,
            check=check,
            text=text,
        )
        return process
    except FileNotFoundError:
        print(f"Error: Command not found: {cmd[0]}", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"Error: Command '{' '.join(cmd)}' failed with exit code {e.returncode}", file=sys.stderr)
        if e.stderr:
            print(f"Stderr:\n{e.stderr}", file=sys.stderr)
        if e.stdout:
             print(f"Stdout:\n{e.stdout}", file=sys.stderr)
        sys.exit(e.returncode)
    except Exception as e:
        print(f"An unexpected error occurred while running {' '.join(cmd)}: {e}", file=sys.stderr)
        sys.exit(1)


def get_user_instruction(message_arg):
    """Gets the user instruction either from args or by launching EDITOR."""
    if message_arg:
        return message_arg

    editor = os.environ.get('EDITOR', 'vi')
    initial_text = "Replace this text with your instructions. Then write to this file and exit your text editor."

    try:
        with tempfile.NamedTemporaryFile(mode='w+', suffix=".txt", delete=False) as tmpfile:
            tmpfile.write(initial_text)
            tmpfile.flush()
            tmp_path = tmpfile.name

        # Run the editor - use run instead of Popen to wait for it
        run_command([editor, tmp_path], capture_output=False, check=True)

        # Read the content after editor exits
        with open(tmp_path, 'r') as f:
            instruction = f.read().strip()

        # Clean up the temp file
        os.unlink(tmp_path)

        if not instruction or instruction == initial_text:
            print("Error: No instruction provided.", file=sys.stderr)
            sys.exit(1)
        return instruction

    except Exception as e:
        print(f"Error getting user instruction via editor: {e}", file=sys.stderr)
        if 'tmp_path' in locals() and os.path.exists(tmp_path):
             os.unlink(tmp_path) # Ensure cleanup on error
        sys.exit(1)


def get_system_message(system_arg):
    """Gets the system message either from args or default file."""
    if system_arg:
        # Check if it's a file path that exists
        if os.path.exists(system_arg):
             try:
                 with open(system_arg, 'r') as f:
                     return f.read()
             except IOError as e:
                 print(f"Error reading system file {system_arg}: {e}", file=sys.stderr)
                 sys.exit(1)
        else:
             # Assume it's the literal system message string
             return system_arg
    else:
        # Default path
        config_home = os.environ.get('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))
        default_path = Path(config_home) / 'hinata' / 'prompts' / '01-targetreplace.md'
        try:
            with open(default_path, 'r') as f:
                return f.read()
        except FileNotFoundError:
            print(f"Error: Default system file not found: {default_path}", file=sys.stderr)
            sys.exit(1)
        except IOError as e:
            print(f"Error reading default system file {default_path}: {e}", file=sys.stderr)
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Edit files using hinata LLM agent.",
        epilog="Example: hnt-edit -m 'Refactor foo function' src/main.py src/utils.py"
    )
    parser.add_argument(
        '-s', '--system',
        help="System message string or path to system message file. Defaults to $XDG_CONFIG_HOME/hinata/prompts/01-targetreplace.md"
    )
    parser.add_argument(
        '-m', '--message',
        help="User instruction message. If not provided, $EDITOR will be opened."
    )
    parser.add_argument(
        'source_files',
        nargs='+',
        help="One or more source files to edit."
    )
    args = parser.parse_args()

    # 1. Get system message
    system_message = get_system_message(args.system)

    # 2. Get user instruction
    instruction = get_user_instruction(args.message)

    # 3. Run llm-pack
    llm_pack_cmd = ['llm-pack'] + args.source_files
    llm_pack_result = run_command(llm_pack_cmd, capture_output=True, check=True, text=True)
    packed_sources = llm_pack_result.stdout

    # 4. Prepare input for hnt
    hnt_input = f"User request:\n{instruction}\n\nSource reference:\n{packed_sources}"

    # 5. Run hnt -s, stream and capture output
    hnt_cmd = ['hnt', '-s', system_message]
    hnt_output_capture = io.StringIO()

    try:
        # Use Popen for streaming stdout
        hnt_process = subprocess.Popen(
            hnt_cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE, # Capture stderr too
            text=True,
            bufsize=1 # Line buffered
        )

        # Write input to hnt's stdin
        hnt_process.stdin.write(hnt_input)
        hnt_process.stdin.close() # Signal EOF

        # Stream stdout and capture
        while True:
            line = hnt_process.stdout.readline()
            if not line:
                break
            sys.stdout.write(line) # Stream to terminal
            sys.stdout.flush()
            hnt_output_capture.write(line) # Capture

        # Wait for process to finish and check return code
        hnt_process.wait()
        if hnt_process.returncode != 0:
             # Read any remaining stderr
             stderr_output = hnt_process.stderr.read()
             print(f"\nError: 'hnt -s' failed with exit code {hnt_process.returncode}", file=sys.stderr)
             if stderr_output:
                 print(f"Stderr:\n{stderr_output}", file=sys.stderr)
             sys.exit(hnt_process.returncode)

    except FileNotFoundError:
        print(f"Error: Command not found: {hnt_cmd[0]}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred while running {' '.join(hnt_cmd)}: {e}", file=sys.stderr)
        # Ensure process is terminated if it's still running
        if 'hnt_process' in locals() and hnt_process.poll() is None:
            hnt_process.terminate()
        sys.exit(1)

    final_hnt_output = hnt_output_capture.getvalue()
    hnt_output_capture.close()

    # 6. Run hnt-apply
    hnt_apply_cmd = ['hnt-apply'] + args.source_files
    run_command(hnt_apply_cmd, stdin_content=final_hnt_output, capture_output=False, check=True, text=True)

    print("\nhnt-edit: Edits applied successfully.")


if __name__ == "__main__":
    main()
